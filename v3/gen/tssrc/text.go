package tssrc

// 报错行号+3
const templateText = `// Generated by github.com/greatwing/tabtoy
// DO NOT EDIT!!
// Version: {{.Version}}
export namespace {{.PackageName}} {
	{{range $sn, $objName := $.Types.EnumNames}}
	export enum {{$objName}} { {{range $fi,$field := $.Types.AllFieldByName $objName}}
		{{$objName}}_{{$field.FieldName}} = {{$field.Value}}, // {{$field.Name}} {{end}}
	}{{end}}

	{{range $sn, $objName := $.Types.StructNames}}
	export class {{$objName}} { {{range $fi,$field := $.Types.AllFieldByName $objName}}
		{{$field.FieldName}} : {{TSType $field}} // {{$field.Name}} {{end}}
	}
	{{end}}

	// Combine struct
	export class {{.CombineStructName}} { {{range $ti, $tab := $.Datas.AllTables}}
		{{$tab.HeaderType}} : {{$tab.HeaderType}}[] // table: {{$tab.HeaderType}} {{end}}

		// Indices {{range $ii, $idx := GetIndices $}}
		{{$idx.Table.HeaderType}}By{{$idx.FieldInfo.FieldName}} : Dictionary<{{$idx.Table.HeaderType}}> // table: {{$idx.Table.HeaderType}} {{end}}

		{{if HasKeyValueTypes $}}
		//{{range $ti, $name := GetKeyValueTypeNames $}} table: {{$name}}
		GetKeyValue_{{$name}}(): {{$name}}{
			return this.{{$name}}[0]
		}
		{{end}}{{end}}

		static FromJSON(json: Object|string): Table {
			let result: Table;
            if (typeof json === 'string') {
                // if it's a string, parse it first
                result= JSON.parse(json, Table.reviver);
            } else {
                // create an instance of the Table class
                let tbl = new Table()
                // copy all the fields from the json object
                result = Object.assign(tbl, json);
            }
			result.BuildData();
			return result;
		}

        static reviver(key: string, value: any): any {
            return key === "" ? Table.FromJSON(value) : value;
        }

		// 清除索引和数据
		ResetData() {
			{{range $ti, $tab := $.Datas.AllTables}}
			this.{{$tab.HeaderType}} = [] {{end}}
			{{range $ii, $idx := GetIndices $}}
			this.{{$idx.Table.HeaderType}}By{{$idx.FieldInfo.FieldName}} = new Dictionary<{{$idx.Table.HeaderType}}>() {{end}}
		}

		// 构建索引
		BuildData() {
			{{range $ii, $idx := GetIndices $}}
			this.{{$idx.Table.HeaderType}}By{{$idx.FieldInfo.FieldName}} = new Dictionary<{{$idx.Table.HeaderType}}>()
			for(let v of this.{{$idx.Table.HeaderType}}) {
				this.{{$idx.Table.HeaderType}}By{{$idx.FieldInfo.FieldName}}.set(v.{{$idx.FieldInfo.FieldName}}, v)
			}{{end}}
		}
	}

	export class Dictionary<V> {
		items: Object = {}

		has(key: string|number): boolean {
            return key in this.items;
        }
        set(key: string|number, value: V) {
            this.items[key] = value;
        }
        remove(key: string|number): boolean {
            if(this.has(key)) {
                delete this.items[key];
                return true;
            }
            return false;
        }
        get(key: string|number): V {
            return this.has(key) ? this.items[key] : undefined;
        }
        values(): V[]{
            let values = [];
            for(var k in this.items){
                values.push(this.items[k]);
            }
            return values;
        }
        clear(){
            this.items = {};
        }
        size(): number{
            var count = 0;
            for(var k in this.items) {
                count++;
            }
            return count;
        }
        getItems(): Object{
            return this.items;
        }
	}

	//Polyfill
    if (typeof Object.assign !== 'function') {
        // Must be writable: true, enumerable: false, configurable: true
		Object.defineProperty(Object, "assign", {
			value: function assign(target, varArgs) { // .length of function is 2
            	'use strict';
            	if (target === null || target === undefined) {
              		throw new TypeError('Cannot convert undefined or null to object');
            	}
      
            	var to = Object(target);
      
            	for (var index = 1; index < arguments.length; index++) {
              		var nextSource = arguments[index];
      
              		if (nextSource !== null && nextSource !== undefined) { 
                		for (var nextKey in nextSource) {
                  			// Avoid bugs when hasOwnProperty is shadowed
                  			if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    			to[nextKey] = nextSource[nextKey];
                  			}
						}
              		}
            	}
            	return to;
			},
			writable: true,
			configurable: true
        });
    }
}
`

